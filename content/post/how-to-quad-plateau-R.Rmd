---
title: "Fit quadratic-plateau models in R"
lastmod: '2021-05-12'
slug: quad-plateau
description: Agricultural yields go up a curve, then level off.
tags:
- statistics
- modeling
- soil chemistry
- soil testing
- soil correlation
- crops
- R
image: /quad-plateau.png
editor_options:
  chunk_output_type: console
---

Like [my post on linear-plateau models in R](https://gradcylinder.org/linear-plateau/), this post is for the person[^1] who has been googling how to fit quadratic-plateau models in R. One resource I came across in my googles was the [`rcompanion`](https://rcompanion.org/handbook/I_11.html) package, which was a big help in finally figuring out how to fit non-linear models to agricultural data.

[^1]: Probably a grad student

This post provides my creative function that helps one do quadratic-plateau fits *and* make a `ggplot` style figure all at once.

So first, load some packages.

```{r setup, message=FALSE}
library(tidyverse)
library(broom)
library(rcompanion)
library(minpack.lm)
library(nlstools)
library(agridat)
```

```{r theme, include=FALSE}
library(extrafont)

rc <- c("Roboto Condensed")

# My own ggplot2 theme
theme_gradcylinder <- theme_minimal(base_family = rc,
                                    base_size = 14) +
    theme(
      plot.background = NULL,
      plot.margin = margin(t = 2, r = 2, b = 2, l = 2, unit = "pt"),
      panel.grid = element_line(color = "#F9F9F9"),
      panel.border = element_blank(),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.title.y = element_text(
        hjust = 1,
        margin = margin(t = 0, r = 10, b = 0, l = 0, unit = "pt")),
      axis.title.x = element_text(
        hjust = 0,
        margin = margin(t = 10, r = 0, b = 0, l = 0, unit = "pt")),
      axis.text = element_text(family = rc),
      legend.title.align = 0,
      legend.key.height = unit(x = 5, units = "mm"),
      legend.justification = c(1, 1),
      legend.position = c(1, 1)
    )

theme_set(theme_gradcylinder)
```

## The data

The data is from some cotton trials in the `agridat` package. Basically, more potassium measured in the soil should correlate to more cotton yield, but the relationship will not be linear. Fitting a model to determine something about this relationship is central to the soil-test correlation process. Let's plot it.

```{r data}
cotton <- tibble(potassium = agridat::cate.potassium$potassium,
                 yield = agridat::cate.potassium$yield)

cotton %>% 
  ggplot(aes(potassium, yield)) +
  geom_point(size = 2, alpha = 0.5) +
  geom_rug(alpha = 0.5, length = unit(2, "pt")) +
  scale_x_continuous(breaks = seq(0, 1000, 20)) +
  scale_y_continuous(breaks = seq(0, 200, 5)) +
  labs(title = paste(
    "Relative yield and soil potassium for", nrow(cotton), "cotton trials"),
    y = "Relative yield (%)",
    x = "Concentration of Soil Potassium (ppm)")
  
```

The relationship between soil-test potassium (STK) and relative cotton yield may be non-linear. Perhaps a polynomial function could be fit, or the data could be transformed, but we'll fit a non-linear model known as the quadratic-plateau. Quadratic-plateau models are also called **quad-plats**[^2]. Quad-plats are good in that they have a curved component (important to biological systems) followed by a zero-slope plateau (convenient for researchers).

[^2]: This isn't true, but I wish it was.

```{r qp-1}
qp <- function(x, a, b, c) {
    if_else(condition = x < c,
            true  = a + b * x + (-0.5 * b / c) * x * x,
            false = a + b * c + (-0.5 * b / c) * c * c)
}
```

This function says that up until some join-point, the relationship is a second-order polynomial (quadratic), after which it hits a flat line (plateau). This model is sometimes also called *quadratic-plus-plateau*. That join-point is important; in the context of soil fertility it represents a critical concentration for the nutrient in the soil. The join-point of a quad-plateau will always be higher than with a linear-plateau, an important consideration for later.

Below is my big function to fit the model and either plot it visually or get useful numbers into a table. I'm not a function wizard, but I'm trying, so forgive any poor coding practices. That's why in my function, I've just put in the variables `yield` and `potassium`,

```{r qp-2}
# only works if x = "potassium" and y = "yield"
quad_plateau <- function(data, confidence = 95) {
    # initial values
    initial_fit <- lm(yield ~ poly(potassium, 2, raw = TRUE),
                      data = data)
    start_a <- initial_fit$coef[[1]]
    start_b <- initial_fit$coef[[2]]
    start_c <- mean(data$potassium)
    
    # Quad plateau model
    corr_model <<- nlsLM(
        formula = yield ~ qp(potassium, a, b, c),
        data = data,
        start = list(a = start_a, b = start_b, c = start_c),
        control  = nls.lm.control(maxiter = 1000)
    )
    
    # Residual plots and normality
        # nls_resid <- nlsResiduals(corr_model)
        # plot(nls_resid, which = 0)
    
    # Define null model
    nullfunct <- function(x, m) {
      m
    }
    
    m.ini <- mean(data$yield)
    
    null <- nls(yield ~ nullfunct(potassium, m),
                data = data,
                start = list(m = m.ini),
                trace = FALSE,
                control = nls.lm.control(maxiter = 1000))
    
    # Find p-value and pseudo R-squared
    pseudo_r2 <- nagelkerke(corr_model, null)
    label_pseudo_r2 <- pseudo_r2$Pseudo.R.squared.for.model.vs.null[3]
    
    # print and set confidence interval
    ci <- confint2(corr_model, level = (confidence / 100))
    ci_lower <- round(ci[3, 1], 1)
    ci_upper <- round(ci[3, 2], 1)
    
    # get model coefficients
    b0 <- tidy(corr_model)$estimate[1]
    b1 <- tidy(corr_model)$estimate[2]
    jp <- tidy(corr_model)$estimate[3] # jp = join point of segmented regression
    b2 <- round(-0.5 * b1 / jp, 4)
    plateau_qp <- round(
        b0 + b1 * jp + (-0.5 * b1 / jp) * jp * jp, 2)
    
    equation <- paste0(round(b0, 1), " + ",
                       round(b1, 2), "x + ",
                       round(b2, 3), "x^2")
    
    se_b0 <- tidy(corr_model)$std.error[1]
    se_b1 <- tidy(corr_model)$std.error[2]
    se_b2 <- tidy(corr_model)$std.error[3]
    
    pval_b0 <- tidy(corr_model)$p.value[1]
    pval_b1 <- tidy(corr_model)$p.value[2]
    pval_b2 <- tidy(corr_model)$p.value[3]
    
    pval_b0 <- case_when(
        tidy(corr_model)$p.value[1] > 0.05 ~ "NS",
        tidy(corr_model)$p.value[1] <= 0.001 ~ "***",
        tidy(corr_model)$p.value[1] <= 0.01 ~ "**",
        tidy(corr_model)$p.value[1] <= 0.05 ~ "*")

    pval_b1 <- case_when(
        tidy(corr_model)$p.value[2] > 0.05 ~ "NS",
        tidy(corr_model)$p.value[2] <= 0.001 ~ "***",
        tidy(corr_model)$p.value[2] <= 0.01 ~ "**",
        tidy(corr_model)$p.value[2] <= 0.05 ~ "*")

    pval_b2 <- case_when(
        tidy(corr_model)$p.value[3] > 0.05 ~ "NS",
        tidy(corr_model)$p.value[3] <= 0.001 ~ "***",
        tidy(corr_model)$p.value[3] <= 0.01 ~ "**",
        tidy(corr_model)$p.value[3] <= 0.05 ~ "*")
    
    # Printouts
    print(
      tibble(
        equation,
        plateau_qp,
        critical = round(jp, 0),
        ci_lower,
        ci_upper,
        model_rsq = pseudo_r2$Pseudo.R.squared.for.model.vs.null[3],
        model_error = summary(corr_model)$sigma,
        se_b0,
        se_b1,
        se_b2,
        pval_b0,
        pval_b1,
        pval_b2
      )
    )
      
    # ggplot of data
    data %>%
      ggplot(aes(x = potassium, y = yield)) +
      geom_hline(yintercept = 100,
                 alpha = 0.2) +
      geom_vline(xintercept = round(jp, 0),
                 linetype = 3,
                 alpha = 0.5) +
      geom_point(size = 2, alpha = 0.5) +
      geom_line(
        stat = "smooth",
        method = "nlsLM",
        formula = y ~ qp(x, a, b, c),
        method.args = list(start = as.list(coef(corr_model))),
        se = FALSE,
        color = "black",
        alpha = 0.5,
      ) +
      annotate(
        "text",
        label = paste(
          equation,
          "\nR^2 =",
          round(label_pseudo_r2, 3),
          "\nPlateau =",
          round(plateau_qp, 1),
          "% RY",
          "\nCritical conc. =",
          round(jp, 0),
          "ppm",
          "\nConf Int [",
          ci_lower,
          ",",
          ci_upper,
          "]"
        ),
        x = max(data$potassium) * 0.7,
        y = min(data$yield) * 1.2,
        hjust = 0,
        family = rc
      )
}
```

## What is going on in that 'function'?

1.  Get initial values for the `nlsLM()` function coming up.
  
  - this can be done by fitting a quadratic model, and yanking out coefficients.

2.  Run `nlsLM()`[^3] with the `qp()` model as part of the formula.
3.  Make a null model, and get a pseudo-R^2^ value.
4.  Get a confidence interval for the join-point (critical soil test value).
5.  Get coefficients from model for use in table and plot.
6.  Make a line from coefficients, and plot it with the cotton yield data.

[^3]: `nlsLM()` seems more reliable overall than plain `nls()` from base R. I've had decent luck with nls(), but sometimes it fails. `nlsLM()` seems to fail less. You can test their similarity by using *a*, *b*, *c* coefficients in the output of `nlsLM()` as inputs to `nls()`.

## The result

So how do you fit a quadratic-plateau model in R? Like this:

```{r qp-3}
quad_plateau(cotton) +
  labs(title = paste(
    "Relative yield and soil potassium for", nrow(cotton), "cotton trials"),
    y = "Relative yield (%)",
    x = "Soil Test Potassium (ppm)")
```

```{r save, eval=FALSE, include=FALSE}
ggsave("static/quad-plateau.png", dpi = 300, width = 7, height = 5)
```

The critical soil concentration for potassium appears to be around 86 ppm, higher than the linear-plateau model. The confidence interval for the join-point is also wider than the "lp" model. The model summary shows that most of the error comes from the the *a* and *c* parameters, essentially the intercept and join-point. The pseudo-R^2^ is about 0.67, so pretty good for noisy yield data. Still, the distribution of points has gaps in it, which limits the confidence of the correlation.

Now, what if the two points with "high" STK (> 180 ppm), were removed? How would that change the analysis? Go back and test yourself[^4]. How do other models compare? Linear-plateau? Mitscherlich-Bray?

[^4]: Hint: `filter()`
