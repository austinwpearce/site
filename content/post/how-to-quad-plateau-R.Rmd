---
title: "Fit quadratic-plateau models in R"
lastmod: "2021-02-20"
slug: quad-plateau
description: "Agricultural yields go up a curve, then level off."
tags:
- statistics
- modeling
- soil chemistry
- soil testing
- soil correlation
- crops
- R
editor_options: 
  chunk_output_type: console
---

The `rcompanion` package is the main reason I figured out how to fit non-linear models to agricultural data. Go [reference it here](https://rcompanion.org/handbook/I_11.html). I'll wait.

Like [my post on linear-plateau models](https://gradcylinder.org/linear-plateau/) in R, this post is for the person who has been googling how to fit quadratic-plateau models in R. Quadratic-plateau models are also know as **quad-plats**[^1]. This post provides my function within another function that sort of helps one do quadratic-plateau fits *and* make a `ggplot` style figure all at once.

[^1]: This isn't true, but I wish they were.

So first, load some packages.

```{r setup, message=FALSE}
library(tidyverse)
library(rcompanion)
library(minpack.lm)
library(nlstools)
library(agridat)
```

```{r theme, include=FALSE}
library(extrafont)

rc <- c("Roboto Condensed")

# My own ggplot2 theme
theme_gradcylinder <- theme_minimal(base_family = rc,
                                    base_size = 14) +
    theme(
      plot.background = NULL,
      plot.margin = margin(t = 2, r = 2, b = 2, l = 2, unit = "pt"),
      panel.grid = element_line(color = "#F9F9F9"),
      panel.border = element_blank(),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.title.y = element_text(
        hjust = 1,
        margin = margin(t = 0, r = 10, b = 0, l = 0, unit = "pt")),
      axis.title.x = element_text(
        hjust = 0,
        margin = margin(t = 10, r = 0, b = 0, l = 0, unit = "pt")),
      axis.text = element_text(family = rc),
      legend.title.align = 0,
      legend.key.height = unit(x = 5, units = "mm"),
      legend.justification = c(1, 1),
      legend.position = c(1, 1)
    )

theme_set(theme_gradcylinder)
```

## The data

The data is from some cotton trials in the `agridat` package. Basically, more potassium measured in the soil should correlate to more cotton yield, but the relationship will not be linear. Fitting a model to determine something about this relationship is central to the soil-test correlation process. Let's plot it.

```{r data}
cotton <- agridat::cate.potassium

cotton %>% 
  ggplot(aes(x = potassium, y = yield)) +
  geom_point(size = 1, alpha = 0.5) +
  geom_rug(alpha = 0.5, length = unit(2, "pt")) +
  scale_x_continuous(breaks = seq(0, 1000, 20)) +
  scale_y_continuous(breaks = seq(0, 200, 5)) +
  labs(title = paste(
    "Relative yield and soil potassium for", nrow(cotton), "cotton trials"),
    y = "Relative yield (%)",
    x = "Concentration of Soil Potassium (ppm)")
  
```

The relationship between soil-test potassium (STK) and relative cotton yield may be non-linear. Perhaps a polynomial function could be fit, or the data could be transformed, but we'll fit a non-linear model known as the quadratic-plateau.

```{r qp-1}
qp <- function(x, a, b, c) {
    if_else(condition = x < c, 
            true  = a + b * x + (-0.5 * b / c) * x * x,
            false = a + b * c + (-0.5 * b / c) * c * c)
}
```

This function says that up until some join-point, the relationship is a second-order polynomial (quadratic), after which it hits a flat line (plateau). Sometimes this model is called *quadratic-plus-plateau*. That join-point is important; it represents a critical concentration for the nutrient in the soil. The join-point will always be higher than with a linear-plateau, an important consideration.

Below is my big function to fit it, get some useful numbers, and plot it. I'm not a function wizard, but I'm trying, so forgive any poor coding practices. That's why in my function, I've just put in the variables `yield` and `potassium`,

## What is going on in the following 'function'?

1.  Get initial values for the `nlsLM()` function coming up.

-   this can be done by fitting a linear model, and yanking out coefficients.

2.  Run `nlsLM()`[^2] with the `qp()` model as part of the formula.
3.  Look at your model summary.
4.  Make a null model, and get a pseudo-R^2^ value.
5.  Get confidence interval for the join-point.
6.  Look at residuals.
7.  Get coefficients from model for use in `ggplot`.
8.  Make a line from coefficients, and plot it with the cotton yield data.

[^2]: `nlsLM()` is more reliabel overall than plain `nls()`. I've had pretty good luck with nls(), but sometimes it fails. `nlsLM()` seems to fail less. You can test their similarity by using *a*, *b*, *c* coefficients in the output of `nlsLM()` as inputs to `nls()`.

```{r qp-2}
# run model and graph all in one!
quad_plateau <- function(data) {
  # initial values
  ini_fit <- lm(data = data, formula = yield ~ potassium)
  ini_a <- ini_fit$coefficients[[1]]
  ini_b <- ini_fit$coefficients[[2]]
  ini_c <- mean(data$potassium)
  
  # linear plateau model
  qp_model <<- nlsLM(
    formula = yield ~ qp(potassium, a, b, c),
    data = data,
    start = list(a = ini_a, b = ini_c, c = ini_c)
  )
  
  print(summary(qp_model))
  
  
  # Define null model
  nullfunct <- function(x, m) {
    m
  }
  m.ini <- mean(data$yield)
  
  null <- nls(
    yield ~ nullfunct(potassium, m),
    data = data,
    start = list(m = m.ini),
    trace = FALSE,
    nls.control(maxiter = 1000)
  )
  
  # Find p-value and pseudo R-squared
  pseudo_r2 <- nagelkerke(qp_model, null)[2]
  print(pseudo_r2)
  
  # print and set confidence interval
  confinterval <- confint2(qp_model, level = 0.95)
  conflo <- round(confinterval[3, 1], 1)
  confhi <- round(confinterval[3, 2], 1)
  print("Confidence Interval")
  print(confinterval)
  
  plotNormalHistogram(residuals(qp_model))
  plot(fitted(qp_model), residuals(qp_model))
  
  a  <- coef(qp_model)[[1]]
  b  <- coef(qp_model)[[2]]
  cc <- coef(qp_model)[[3]]
  quad <- -0.5 * b / cc
  plateau <- a + b * cc + (-0.5 * b / cc) * cc * cc
  
  print(paste("Quad coeff", quad))
  print(paste("Plateau at ", plateau, "% RY"))
  
  # other plot
  data %>%
    ggplot(aes(x = potassium, y = yield)) +
    geom_point(size = 1, alpha = 0.5) +
    geom_rug(alpha = 0.5, length = unit(2, "pt")) +
    geom_vline(xintercept = cc,
               color = "#CC0000") +
    geom_vline(
      xintercept = c(conflo, confhi),
      color = "#CC0000",
      alpha = 0.2
    ) +
    geom_smooth(method = "nlsLM",
                formula = y ~ qp(x, a, b, c),
                method.args = list(start = as.list(coef(qp_model))),
                se = FALSE,
                color = "#4156a1",
                size = 0.5) +
    scale_x_continuous(breaks = seq(0, 1000, 20)) +
    scale_y_continuous(breaks = seq(0, 200, 5)) +
    labs(subtitle = paste0(
      "Critical concentraion = ",
      round(cc, 0),
      " ppm; 95% CL [",
      conflo,
      ", ",
      confhi,
      "]"
    ))
}
```

## The result

So how do you fit a quadratic-plateau model in R? Like this:

```{r qp-3}
quad_plateau(cotton) +
  labs(title = paste(
    "Relative yield and soil potassium for", nrow(cotton), "cotton trials"),
    y = "Relative yield (%)",
    x = "Concentration of Soil Potassium (ppm)")
```

The critical soil concentration for potassium appears to be around 86 ppm, higher than the linear-plateau model. The confidence interval for the join-point is also wider than the "lp" model. The model summary shows that most of the error comes from the the *a* and *c* parameters, essentially the intercept and join-point. The pseudo-R^2^ is about 0.67, so not too bad. Still, the distribution of points has gaps in it, which limits the confidence of the correlation.

Now, what if the two points with "high" STK (\> 180 ppm), were removed? How would that change the analysis? Go back and test yourself[^3]. How do other models compare? Linear-plateau? Mitscherlich-Bray?

[^3]: Hint: `filter()`
